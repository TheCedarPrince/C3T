<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <!--WEAVE SYNTAX HIGHLIGHTING--> <link rel=stylesheet  href="/C3T/libs/highlight/github.min.css"> <link href="/C3T/css/franklin.css" rel=stylesheet > <link href="/C3T/css/vela.css" rel=stylesheet > <script src="/C3T/libs/vela/jquery.min.js"></script> <link rel=icon  href="/C3T/assets/favicon.png"> <script src="/C3T/libs/mermaid/mermaid.min.js"></script> <script>mermaid.initialize({startOnLoad:true});</script> <!--WEAVE DOCUMENT INSERTION--> <link rel=stylesheet  href="/C3T/css/weave.css"> <link rel=stylesheet  href="/C3T/libs/katex/katex.min.css"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <title></title> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>üê± C3T üê±</h3> </span> </div> <!--LUNR SEARCH BOX--> <script src="/C3T/libs/lunr/lunr.min.js"></script> <script src="/C3T/libs/lunr/lunr_index.js"></script> <script src="/C3T/libs/lunr/lunrclient.min.js"></script> <style> .result-title a { text-decoration: none; } .result-title a:hover { text-decoration: underline; } .result-preview { color: #808080; } .resultCount { color: #808080; } .result-query { font-weight: bold; } #lunrSearchForm { margin-top: 1em; } </style> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu > <li><a href="/C3T/">Home</a> <li> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/C3T/search/index.html"> </form> <li><a href="/C3T/" class=has-arrow >Resources</a> <ul> <li><a href="/C3T/resources/">Resources Overview</a> <li><a href="/C3T/" class=has-arrow >Books</a> <ul> <li><a href="/C3T/books/">Books Resource Guide</a> <li><a href="/C3T/" class=has-arrow >Category Theory for Programmers</a> <ul> <li><a href="/C3T/milewski-programmers-1">Chapter 1</a> <li><a href="/C3T/milewski-programmers-2">Chapter 2</a> <li><a href="/C3T/milewski-programmers-3">Chapter 3</a> <li><a href="/C3T/milewski-programmers-4">Chapter 4</a> </ul> <li><a href="/C3T/" class=has-arrow >Category Theory for the Sciences</a> <ul> <li><a href="/C3T/11082021041951-category-theory-scientists">Overview</a> <li><a href="/C3T/02192022223803-scientists-introduction">Chapter 1</a> <li><a href="/C3T/" class=has-arrow >Chapter 2</a> <ul> <li><a href="/C3T/02192022224435-category-sets">Overview</a> <li><a href="/C3T/02212022050947-sets.md">Subsection 2.1.1</a> <li><a href=02212022051418-functions.md >Subsection 2.1.2</a> </ul> </ul> </ul> <li><a href="/C3T/" class=has-arrow >Software</a> <ul> <li><a href="/C3T/software/">Software Resource Guide</a> </ul> </ul> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title"></h1> <hr> <div class=franklin-content > <div class ="container"> <div class = "row"> <div class = "col-md-12 twelve columns"> <div class=title > </div> <h3>Categories Great and Small</h3> <blockquote> <p>What is the most trivial type of category?</p> </blockquote> <p>The one with no objects and therefore no morphisms.</p> <blockquote> <p>What is an example process of converting a directed graph to a category?</p> </blockquote> <p>Starting with a directed graph as follows:</p> <div class=mermaid >graph LR; A --&gt; B; B --&gt; C; C --&gt; D; D --&gt; E;</div> <p>It can be transformed into a category. The way of doing this is to start with adding the identity arrows at each node in the directed graph.</p> <div class=mermaid >graph LR; A --&gt; B; B --&gt; C; C --&gt; D; D --&gt; E; A --id--&gt; A; B --id--&gt; B; C --id--&gt; C; D --id--&gt; D; E --id--&gt; E; </div> <p>After adding the identity arrows, composition arrows can be created. Composition arrows can be created between any two arrows where the end of one arrow coincides with the beginning of the other. Some of the composition arrows that can be created in this directed graph are as follows:</p> <p>Composition arrow from Node <code>A</code> to Node <code>C</code></p> <div class=mermaid >graph LR; A --&gt; B; B --&gt; C; C --&gt; D; D --&gt; E; A --&gt; C; A --id--&gt; A; B --id--&gt; B; C --id--&gt; C; D --id--&gt; D; E --id--&gt; E; </div> <p>Composition arrow from Node <code>B</code> to Node <code>D</code></p> <div class=mermaid >graph LR; A --&gt; B; B --&gt; C; C --&gt; D; D --&gt; E; B --&gt; D; A --id--&gt; A; B --id--&gt; B; C --id--&gt; C; D --id--&gt; D; E --id--&gt; E; </div> <p>Composition arrow from Node <code>C</code> to Node <code>E</code></p> <div class=mermaid >graph LR; A --&gt; B; B --&gt; C; C --&gt; D; D --&gt; E; C --&gt; E; A --id--&gt; A; B --id--&gt; B; C --id--&gt; C; D --id--&gt; D; E --id--&gt; E; </div> <p>This next arrow also shows the composition of all compositions previously made. It looks like an arrow from node <code>A</code> to <code>E</code> but is composed of the arrows made before:</p> <div class=mermaid >graph LR; A --&gt; B; B --&gt; C; C --&gt; D; D --&gt; E; A --&gt; E; A --id--&gt; A; B --id--&gt; B; C --id--&gt; C; D --id--&gt; D; E --id--&gt; E; </div> <p>Furthermore, there can be near infinite compositions between each of these nodes. The compositions shown above were examples of some of the compositions that could be made using the morphisms and nodes found in a directed graph.</p> <blockquote> <p>How is a free category made through free construction?</p> </blockquote> <p>A free category is created through free construction where a starting structure is extended with the minimum number of items to satisfy the laws of a category. One example is the identity condition.</p> <blockquote> <p>What is an example of a preorder set being a category?</p> </blockquote> <p>Say we have the preorder set statement: <span class=math >$A \leq B \leq C$</span> To show that this is in fact a qualified category, we must prove the identity and composition requirements of a category. Visualizing this, we can have the graph representation of the statement:</p> <div class=mermaid >graph LR; A --&lt;&#61;--&gt; B; B --&lt;&#61;--&gt; C;</div> <p>To prove the identity condition, we can state the following identity statements:</p> <p class=math >\[ A \leq A \]</p> <p class=math >\[ B \leq B \]</p> <p class=math >\[ C \leq C \]</p> <p>So in this case, identity arrows can be created using this fact:</p> <div class=mermaid >graph LR; A --&lt;&#61;--&gt; B; B --&lt;&#61;--&gt; C; A --&lt;&#61;--&gt; A; B --&lt;&#61;--&gt; B; C --&lt;&#61;--&gt; C;</div> <p>To prove compositionality, given the statements <span class=math >$A \leq B$</span> and <span class=math >$B \leq C$</span>, it follows that <span class=math >$A \leq C$</span>. In this case, <span class=math >$A \leq C$</span> is the composition of the two prior statements. With having demonstrated the identity and compositionality of a preorder, a preorder is a type of category.</p> <blockquote> <p>How can you create a partial order relation?</p> </blockquote> <p>If the statements <span class=math >$A \leq B$</span> and <span class=math >$B \leq A$</span> exist in an order, then it can be said that <span class=math >$A = B$</span>.</p> <blockquote> <p>By enforcing the condition that any two objects are related to one another, what sort of order is created?</p> </blockquote> <p>A linear or total order.</p> <blockquote> <p>What is a thin category?</p> </blockquote> <p>A category where there is at most one morphism between object <span class=math >$A$</span> and object <span class=math >$B$</span>.</p> <blockquote> <p>The set of morphisms from any object <span class=math >$A$</span> to any object <span class=math >$B$</span> in a category <span class=math >$C$</span> is called a what?</p> </blockquote> <p>A <em>hom-set</em> and is denoted as <span class=math >$C(A, B)$</span> or as <span class=math >$\textbf{Hom}_{C}(A, B)$</span>.</p> <blockquote> <p>What are examples of Monoids?</p> </blockquote> <p>Addition and multiplication form a monoid. Additional examples include:</p> <ul> <li><p>Natural numbers</p> <li><p>Strings</p> <li><p>Lists</p> </ul> <blockquote> <p>What is a Monoid?</p> </blockquote> <p>A set with a binary operation. This binary operation must:</p> <ol> <li><p>Be associative</p> <li><p>Contains one element that acts as a unit</p> </ol> <p>The element in <span class=math >$2$</span>, is also referred to as a neutral element.</p> <blockquote> <p>How are natural numbers a monoid?</p> </blockquote> <p>Natural numbers can be classified as monoids as they are associative. Consider three natural numbers, <span class=math >$a$</span>, <span class=math >$b$</span>, and <span class=math >$c$</span> and add them together:</p> <p class=math >\[ (a + b) + c = a + (b + c) \]</p> <p>Furthermore, the neutral element provided in natural numbers is the value, <span class=math >$0$</span>:</p> <p class=math >\[ 0 + a = a \]</p> <blockquote> <p>How can you prove that strings are monoids?</p> </blockquote> <p>Using the following definitions, we can create a proof by example:</p> <pre class='hljl'>
<span class='hljl-cs'># String definitions</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;foo&quot;</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;baz&quot;</span><span class='hljl-t'>
</span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;bar&quot;</span>
</pre> <pre class=output >
&quot;bar&quot;
</pre> <p>Associative proof by example:</p> <pre class='hljl'>
<span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
true
</pre> <p>Neutral element example:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>*</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;&quot;</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span>
</pre> <pre class=output >
true
</pre> <blockquote> <p>How can a monoid be a single object category?</p> </blockquote> <p>A monoid is classified as a single object category as every monoid can be described as a single object category with a corresponding set of morphisms, the hom-set <span class=math >$\textbf{M}(m, m)$</span>, where <span class=math >$\textbf{M}$</span> is the category defined by the monoid and <span class=math >$m$</span> is the single object. The binary operator in this set can be defined as the monoidal product of two set-elements.</p> <p>For example, given two elements from <span class=math >$\textbf{M}(m, m)$</span>, <span class=math >$f$</span> and <span class=math >$g$</span>, the product of these elements will be the composition <span class=math >$f \circ g$</span>. This works as the source and the target for the morphisms are always the same object, <span class=math >$m$</span>. As a result, it is always possible to return a set monoid from a category monoid.</p> <h4>Challenges</h4> <ol> <li><p>Generate a free category from:</p> <ol> <li><p>A graph with one node and no edges</p> <li><p>A graph with one node and one &#40;directed&#41; edge &#40;hint: this edge can be composed with itself&#41;</p> <li><p>A graph with two nodes and a single arrow between them</p> <li><p>A graph with a single node and 26 arrows marked with the letters of the alphabet: a, b, c ‚Ä¶ z. </p> </ol> </ol> <p><strong>For 1.1</strong>, the answer can look like this:</p> <div class=mermaid >graph LR; A --id--&gt; A;</div> <p><strong>For 1.2</strong>, there are infinitely many compositions made alongside the identity arrow. The reason for this is that by the typical definition of a graph&#39;s edge, an edge must have two endpoints. In this case, the directed edge&#39;s starting point and end point are the same node. These edges can be composed infinitely and be valid morphisms of the object &#40;the single node&#41; as they will always start and end at the same object in this category.</p> <p><strong>For 1.3</strong>, the answer could look like this:</p> <div class=mermaid >graph LR; A --&gt; B; A --id--&gt; A; B --id--&gt; B;</div> <p><strong>For 1.4</strong>, the answer is similar to 1.2&#39;s answer as again, there will be infinitely many compositions made alongside the identity arrow. Unlike 1.2, the arrows given here are concrete instead of abstract. For example, using just the letter <span class=math >$a$</span>, the category could start looking like this:</p> <div class=mermaid >graph TD; A --id--&gt; A; A --a--&gt; A; A --aa--&gt; A; A --aaa--&gt; A; A --aaaa--&gt; A; A --aaaaa--&gt; A;</div> <p>Furthermore, as these arrows are composable, they can also start creating compositions which look like this:</p> <div class=mermaid >graph TD; A --id--&gt; A; A --a--&gt; A; A --ab--&gt; A; A --abc--&gt; A; A --abcd--&gt; A; A --abcde--&gt; A;</div> <ol start=2 > <li><p>What kind of order is this?</p> <ol> <li><p>A set of sets with the inclusion relation: <span class=math >$A$</span> is included in <span class=math >$B$</span> if every element of <span class=math >$A$</span> is also an element of <span class=math >$B$</span>.</p> <li><p>C&#43;&#43; types with the following subtyping relation: T1 is a subtype of T2 if a pointer to T1 can be passed to a function that expects a pointer to T2 without triggering a compilation error. </p> </ol> </ol> <p><strong>For 2.1</strong>, this kind of order is known as a partial order.</p> <p>Skipped 2.2</p> <ol start=3 > <li><p>Considering that <code>Bool</code> is a set of two values <code>True</code> and <code>False</code>, show that it forms two &#40;set-theoretical&#41; monoids with respect to, respectively, operator <code>&amp;&amp;</code> &#40;<code>AND</code>&#41; and <code>||</code> &#40;<code>OR</code>&#41;.</p> </ol> <p>Let <code>a</code>, <code>b</code>, <code>c</code>, be of type <code>Bool</code>:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-t'>
</span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span>
</pre> <pre class=output >
true
</pre> <p>We can show the associative property of these two operators as follows:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-n'>c</span>
</pre> <pre class=output >
true
</pre> <p>Monoid around <code>&amp;&amp;</code>:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-kc'>true</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span>
</pre> <pre class=output >
true
</pre> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-kc'>false</span><span class='hljl-t'> </span><span class='hljl-oB'>!=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-kc'>false</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>!=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span>
</pre> <pre class=output >
false
</pre> <p>Monoid around <code>||</code>:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-kc'>true</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span>
</pre> <pre class=output >
true
</pre> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-kc'>false</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-kc'>false</span><span class='hljl-t'> </span><span class='hljl-oB'>||</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span>
</pre> <pre class=output >
true
</pre> <ol start=4 > <li><p>Represent the <code>Bool</code> monoid with the <code>AND</code> operator as a category:</p> </ol> <p>List the morphisms and their rules of composition.</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Bool</span>
</pre> <pre class=output >
Bool
</pre> <pre class='hljl'>
<span class='hljl-cm'>#= Morphisms =#</span><span class='hljl-t'>

</span><span class='hljl-cs'># Identity Morphism</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>&amp;&amp;</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'>

</span><span class='hljl-cs'># Commutative Morphism</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>‚àò</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-n'>a</span>
</pre> <div class=mermaid >graph TD; a --true--&gt; a; a --AND--&gt; a;</div> <ol start=5 > <li><p>Represent addition modulo 3 as a monoid category.</p> </ol> <p>Skipped</p> <HR/> <div class=footer > <p> Published from <a href=milewski-programmers-3.jmd >milewski-programmers-3.jmd</a> using <a href="http://github.com/JunoLab/Weave.jl">Weave.jl</a> v0.10.12 on 2023-04-24. </p> </div> </div> </div> </div> <div class=page-foot > <div class=copyright > &copy; Jacob Zelko. Last modified: April 24, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </main> <script src="/C3T/libs/vela/metisMenu.min.js"></script> <script src="/C3T/libs/vela/slideout.min.js"></script> <script src="/C3T/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <script src="/C3T/libs/katex/katex.min.js"></script> <script src="/C3T/libs/katex/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script>