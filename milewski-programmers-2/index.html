<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <!--WEAVE SYNTAX HIGHLIGHTING--> <link rel=stylesheet  href="/C3T/libs/highlight/github.min.css"> <link href="/C3T/css/franklin.css" rel=stylesheet > <link href="/C3T/css/vela.css" rel=stylesheet > <script src="/C3T/libs/vela/jquery.min.js"></script> <link rel=icon  href="/C3T/assets/favicon.png"> <!--WEAVE DOCUMENT INSERTION--> <link rel=stylesheet  href="/C3T/css/weave.css"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <title></title> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 25px'>üê± C3T üê±</h3> </span> </div> <!--LUNR SEARCH BOX--> <script src="/C3T/libs/lunr/lunr.min.js"></script> <script src="/C3T/libs/lunr/lunr_index.js"></script> <script src="/C3T/libs/lunr/lunrclient.min.js"></script> <style> .result-title a { text-decoration: none; } .result-title a:hover { text-decoration: underline; } .result-preview { color: #808080; } .resultCount { color: #808080; } .result-query { font-weight: bold; } #lunrSearchForm { margin-top: 1em; } </style> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/C3T/">Home</a> <li> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/C3T/search/index.html"> </form> <li><a href="/C3T/" class=has-arrow >Resources</a> <ul> <li><a href="/C3T/resources/">Resources Overview</a> <li><a href="/C3T/" class=has-arrow >Books</a> <ul> <li><a href="/C3T/books/">Books Resource Guide</a> <li><a href="/C3T/" class=has-arrow >Category Theory for Programmers</a> <ul> <li><a href="/C3T/milewski-programmers-1">Chapter 1</a> <li><a href="/C3T/milewski-programmers-2">Chapter 2</a> </ul> <li><a href="/C3T/spivak-sciences/">Category Theory for the Sciences</a> </ul> <li><a href="/C3T/" class=has-arrow >Software</a> <ul> <li><a href="/C3T/software/">Software Resource Guide</a> </ul> </ul> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title"></h1> <hr> <div class=franklin-content > <div class ="container"> <div class = "row"> <div class = "col-md-12 twelve columns"> <div class=title > </div> <h1>Types and Functions</h1> <blockquote> <p>At its core, what is category theory about?</p> </blockquote> <p>Category Theory is about composability. This means that the target of one arrow must be the source for the next arrow. In programming, this means that the results of one function must be the input into the next function.</p> <blockquote> <p>Why is the category of sets, <strong>Set</strong>, special?</p> </blockquote> <p>In <strong>Set</strong>, the objects are sets and the morphisms are functions &#40;or mappings&#41; between the objects. This category allows us to know what are inside the objects by definitions provided by Set Theory.</p> <blockquote> <p>Where does the analogy between programming functions and mathematical functions breakdown?</p> </blockquote> <p>A mathematical function just knows the answer for a given function definition. A programmed function must calculate the answer.</p> <blockquote> <p>What is the &quot;bottom&quot; of every type?</p> </blockquote> <p>The &quot;bottom&quot;, denoted as <span class=math >$\bot$</span>, signifies a non-terminating computation. Functions that return a &quot;bottom&quot; are partial. Functions that do not are total as they return valid results for every possible input.</p> <blockquote> <p>What is the difference between operational and denotational semantics?</p> </blockquote> <p>Operational semantics concerns the definition of an idealized and formalized interpreter. Using this idealization and language, one can reason abstractly about a program&#39;s execution. However, what is difficult about this approach is that the abstract reasoning about the language can be very difficult to verify.</p> <p>Denotational semantics instead assigns a mathematical definition to every programming construct in a given language. Rather than reasoning about a program&#39;s execution, you instead reason about the mathematics.</p> <blockquote> <p>What was Eugenio Moggi&#39;s core contribution to programming and category theory?</p> </blockquote> <p>Eugenio Moggi discovered how computational effect can be mapped to the concepts of monads. This also enabled the expansive use of denotational semantic reasoning across the entirety of programming.</p> <blockquote> <p>What is a pure function in programming?</p> </blockquote> <p>A <a href=11082021225843-pure-functions.md >pure function</a> is one in which the same result is always produced with no side effects given the same input.</p> <blockquote> <p>What is a parametrically polymorphic function?</p> </blockquote> <p>A parametrically polymorphic function is one that uses the same formulation for any type given to it. An example would be:</p> <pre><code class=language-haskell >myfunction :: a -&gt; &#40;&#41;
myfunction _ &#61; &#40;&#41;</code></pre> <h2>Challenges</h2> <ol> <li><p>Define a higher-order function &#40;or a function object&#41; memoize in your favorite language.</p> </ol> <p>This function takes a pure function <code>f</code> as an argument and returns a function that behaves almost exactly like <code>f</code>, except that it only calls the original function once for every argument, stores the result internally, and subsequently returns this stored result every time it&#39;s called with the same argument. You can tell the memoized function from the original by watching its performance. For instance, try to memoize a function that takes a long time to evaluate. You‚Äôll have to wait for the result the first time you call it, but on subsequent calls, with the same argument, you should get the result immediately.</p> <p>This was an initial solution I came up with. It works properly but is somewhat unoptimized and is somewhat brittle. By brittle, it only works for one specific function. If I try to use another function, it will access information about the last memoized function.</p> <pre class='hljl'>
<span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>m_cache</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Dict</span><span class='hljl-p'>{</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Int</span><span class='hljl-p'>}()</span><span class='hljl-t'>

</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoize</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
	</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoized</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>f</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
		</span><span class='hljl-nf'>get!</span><span class='hljl-p'>(</span><span class='hljl-n'>m_cache</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>do</span><span class='hljl-t'>
			</span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
		</span><span class='hljl-k'>end</span><span class='hljl-t'>
	</span><span class='hljl-k'>end</span><span class='hljl-t'>
	</span><span class='hljl-k'>return</span><span class='hljl-t'> </span><span class='hljl-nf'>m</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>memoized</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>f</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nf'>fact</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-oB'>*</span><span class='hljl-p'>)</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-n'>x</span><span class='hljl-oB'>...</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>f</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>fact</span><span class='hljl-t'>
</span><span class='hljl-n'>m</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>memoize</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>m</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
3628800
</pre> <p>Here is another solution that came from Alberto Braunstein from the Julia community. This solution in my opinion is much more elegant as it gets around the problem of having one cache for specific functions. Instead, the respective memoized function&#39;s cache is forever associated with it:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoize</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>fcache</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Dict</span><span class='hljl-p'>{</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>Int</span><span class='hljl-p'>}()</span><span class='hljl-t'>
    </span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoized</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nf'>get!</span><span class='hljl-p'>(</span><span class='hljl-n'>fcache</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>do</span><span class='hljl-t'>
            </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nf'>fact</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-oB'>*</span><span class='hljl-p'>)</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-n'>x</span><span class='hljl-oB'>...</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>f</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>fact</span><span class='hljl-t'>
</span><span class='hljl-n'>m</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>memoize</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>m</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
3628800
</pre> <ol start=2 > <li><p>Try to memoize a function from your standard library that you normally use to produce random numbers.</p> </ol> <p>Does it work?</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoize</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>fcache</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Dict</span><span class='hljl-p'>()</span><span class='hljl-t'>
    </span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoized</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-nf'>get!</span><span class='hljl-p'>(</span><span class='hljl-n'>fcache</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>do</span><span class='hljl-t'>
            </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
        </span><span class='hljl-k'>end</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-n'>f</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>rand</span><span class='hljl-t'>
</span><span class='hljl-n'>m_rand</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>memoize</span><span class='hljl-p'>(</span><span class='hljl-n'>f</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
&#40;::Main.##WeaveSandBox#257.var&quot;#memoized#11&quot;&#123;typeof&#40;rand&#41;, Dict&#123;Any, Any&#125;&#125;&#41;
 &#40;generic function with 1 method&#41;
</pre> <p>Using this solution, the function does get memoized, but it no longer produces random numbers. Instead, it caches the initial random number and no longer creates random numbers.</p> <ol start=3 > <li><p>Most random number generators can be initialized with a seed.</p> </ol> <p>Implement a function that takes a seed, calls the random number generator with that seed, and returns the result. Memoize that function. Does it work?</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Random</span><span class='hljl-t'>

</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>memoized_rand</span><span class='hljl-p'>(</span><span class='hljl-n'>seed</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>fcache</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Dict</span><span class='hljl-p'>()</span><span class='hljl-t'>
    </span><span class='hljl-nf'>get!</span><span class='hljl-p'>(</span><span class='hljl-n'>fcache</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>seed</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>do</span><span class='hljl-t'>
        </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-nf'>MersenneTwister</span><span class='hljl-p'>(</span><span class='hljl-n'>seed</span><span class='hljl-p'>))</span><span class='hljl-t'>
    </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-n'>seed</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>42</span><span class='hljl-t'>

</span><span class='hljl-nf'>memoized_rand</span><span class='hljl-p'>(</span><span class='hljl-n'>seed</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
0.5331830160438613
</pre> <ol start=4 > <li><p>Which of these C&#43;&#43; functions are pure?</p> </ol> <p>Try to memoize them and observe what happens when you call them multiple times; memoized or not.</p> <p>a. The factorial function from the example in this text.</p> <p>Yes, this is a pure function as it does not produce side effects and is the same for a given input.</p> <p>b. Skipped</p> <p>c. Skipped</p> <p>d. Skipped</p> <ol start=5 > <li><p>How many different functions are there from <code>Bool</code> to <code>Bool</code>?</p> </ol> <p>Can you implement them all?</p> <pre><code>1. &#96;True&#96;
2. &#96;False&#96;
3. &#96;not&#96;
4. &#96;id&#96;</code></pre> <ol start=6 > <li><p>Draw a picture of a category whose only objects are the types <code>Void</code>, <code>&#40;&#41;</code>, and <code>Bool</code>; with arrows corresponding to all possible functions between these types.</p> </ol> <p>Label the arrows with the names of the functions.</p> <div class=mermaid >graph LR; Void -- absurd --&gt; unit; Void -- id --&gt; Void; Bool -- True --&gt; Bool; Bool -- False --&gt; Bool; Bool -- not --&gt; Bool; Bool -- id --&gt; Bool; unit -- True --&gt; Bool; unit -- False --&gt; Bool; unit -- id --&gt; unit; </div> <HR/> <div class=footer > <p> Published from <a href=milewski-programmers-2.jmd >milewski-programmers-2.jmd</a> using <a href="http://github.com/JunoLab/Weave.jl">Weave.jl</a> v0.10.10 on 2021-12-02. </p> </div> </div> </div> </div> <div class=page-foot > <div class=copyright > &copy; Jacob Zelko. Last modified: December 02, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </main> <script src="/C3T/libs/vela/metisMenu.min.js"></script> <script src="/C3T/libs/vela/slideout.min.js"></script> <script src="/C3T/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>